package ru.job4j.stream;

import ru.job4j.stream.mapto.Person;

import java.util.Arrays;
import java.util.List;
import java.util.Optional;

/**
 * Агрегатный метод сведения - reduce(). Метод reduce() применяет операцию ко всем элементам потока.
 * В этом методе понятие агрегации обобщается, так как в нем можно самостоятельно задать критерий
 * для получения значения. Метод является терминальным.
 *
 * Метод reduce() имеет 3 формы,
 */
public class ReduceExample {
    public static void main(String[] args) {
        /**
         * - reduce(BinaryOperator<T> accumulator) - стандартный вариант метода reduce(). Применяет
         * функцию BinaryOperator ко всем элементам потока. Метод работает так: Например, есть поток
         * из чисел 1, 2, 3, 4. Нам нужно сложить все эти числа. Метод reduce() сначала сложит
         * первые2 элемента - (1 + 2 = 3), далее к этому результату будет прибавлен следующий
         * элемент (3 + 3 = 6) и так далее, пока не будут сложены все элементы потока. В результате
         * весь поток будет сведен к единому результату. В нашем случае это сумма всех чисел.
         * Данная форма метода возвращает Optional<T>(значение в обертке).
         * В строке ниже мы передаем BinaryOperator в метод reduce().
         * (a, b) - это первые 2 элемента потока, a + b - это действие, которое нужно применить к
         * этим элементам. На первом шаге эта операция будет выглядеть так: (1, 2) -> 1 + 2. Сумма
         * этих элементов становится первым элементом функции на следующем шаге: (3, 3) -> 3 + 3
         * и так далее, пока метод не сложит все элементы потока в единую сумму.
         * Вместо сложения можно применить любую другую функцию, например, умножение и т.д.
         */
        List<Integer> nums = List.of(1, 2, 3, 4);
        Optional<Integer> sum = nums.stream()
                .reduce((a, b) -> a + b);
        System.out.println(sum);

        /**
         *Аналогично предыдущему примеру мы можем сложить и строки:
         */
        List<String> numsStr = List.of("Один", "Два", "Три");
        Optional<String> sumStr = numsStr.stream()
                .reduce((aS, bS) -> aS + ", " + bS);
        System.out.println(sumStr.get());

        /**
         * - reduce(T identity, BinaryOperator<T> accumulator) - эта версия метода похожа на
         * предыдущую, только в BinaryOperator первым параметром будет identity - значение,
         * к которому будет применяться второй элемент в функции. Если поток будет пуст, то
         * identity останется значением по умолчанию. Данная форма метода возвращает само
         * значение (T).
         * В строке ниже мы так же передаем BinaryOperator в метод reduce(). На этот раз
         * первым параметром будем выступать указанный identity, который складывается с
         * первым элементом (a + b) -> identity + b, на следующем шаге первым параметром в
         * BinaryOperator будет сумма этих элементов, которая будет складываться уже со
         * вторым элементом потока, дальше все шаги аналогичны предыдущей форме метода reduce()
         * Последовательность операций в методе reduce() из примера выше будет такая:
         * 2(identity) + 1 = 3
         * 3 + 2 = 5
         * 5 + 3 = 8
         * 8 + 4 = 12
         */
        List<Integer> numsIdentity = Arrays.asList(1, 2, 3, 4);
        int sumEdentity = numsIdentity.stream()
                .reduce(2, (a, b) -> a + b);
        System.out.println(sumEdentity);

        /**
         * - reduce (U identity, BiFunction<U, ? super T,U> accumulator, BinaryOperator<U>
         *     combiner) - расширенная версия второй формы. accumulator здесь позволяет
         * выполнить промежуточное действие над элементами потока, после чего к ним будет
         * применена агрегатная операция combiner. Данная форма метода аналогична комбинации
         * методов map() и второй формы reduce(), то есть если нам нужно вернуть тип данных,
         * отличный от входящего, то нужно использовать эту версию метода reduce().
         * В строке ниже задаем первый параметр метода reduce() - identity, равный 0, так
         * как суммировать будем с нуля. Если в потоке не будет элементов, заданный
         * identity будет выведен как значение по умолчанию.
         * Следующий блок кода описывает второй параметр метода reduce(), здесь мы
         * получаем из объектов Person промежуточное значение - возраст людей, которым
         * более 25 лет. На этом шаге будет создан новый поток с отобранными по условию
         * числами 35, 26 и 29.
         * В следующей строке выполняем бинарную операцию по суммированию всех элементов.
         * На этом шаге складываются числа из предыдущего шага:
         */
        List<Person> people = Arrays.asList(
                new Person("Михаил", 35),
                new Person("Ольга", 26),
                new Person("Антон", 20),
                new Person("Виктор", 16),
                new Person("Анна", 29)
        );
        int sumInt = people.stream()
                .reduce(
                        0,
                        (a, b) -> {
                            if (b.getAge() > 25) {
                                    return a + b.getAge();
                            } else {
                                return a;
                            }
                        },
                        (a, b) -> a + b
                );
        System.out.println(sumInt);

        
    }
}
